# sudoku-solver
A project to explore different approaches and algorithms for efficiently solving sudoku problems.

### Solution Verification Algorithms:
* _BasicBoardCheck_ - For each cell, check each other cell in row, column, and block for matching values, and for empty cells. Runs in O(n^3), no extra data cost
* _FrequencyCheck_ - Maintain frequency table for each row, each column, each block for how many times each value appears in the grouping. Iterate through cells and increment associated frequencies, checking if any frequency exceeds 1. Also checks for empty cells. Runs in O(n^2) with data cost of mainting 3n additional arrays of size n. Manages lists of arrays using my ArrayBasedList implementation that I made in CSC316 at NC State.

### Solving Algorithms: 
* _PopulateOptions_ - Goes through each empty cell on the board and populates its options with the numbers that could possibly go in that cell without immediately breaking any rules. Runs in O(n^3) for the whole board, or O(n) for a single cell. For our purposes, n represents the size of the board, so there would be n^2 cells in a board of size n.
* _PruneBoard_ - Fills in each cell that only has a single possible option with that option, updates the other options in that cell's row, column, and block accordingly, then checks again for 1-option cells and repeats until it runs out of cells that it can solve. Runs in O(n^4), or expected T(n) = 12n^4 + n^3
* _FrequencyPrune_ - Checks each row, column, and block for numbers that only appear in that grouping once as an option, and solves the cell where that number appears. After doing that for each instance it could on its first look through the board, it repopulates the options for the empty cells and looks again, until it runs out of cells to solve. Runs in worst case O(n^6), but expected time is O(n^5).
* _OptionPrune_ - Not implemented yet, the idea is to look through the board's groupings and calculate option frequencies just like _FrequencyPrune_ does, but instead of solving the 1-frequency cells it would use the N-Sibling and Hidden Sibling strategies (see SudokuSolver/docs/Sudoku Solving Strategies) to remove options from cells. Runtime should be similar to _FrequencyPrune_.
* _Start-N-Swap_ - Might not be particularly fast but was an interesting idea I had. Could start with a prefilling a SudokuBoard (and then saving that SudokuBoard for future use), and then comparing that board to the starting board that we are trying to solve. If they are not equal, switch cells around until you have a board that matches the hints on the original. Or, on the flip side, fill in the starting board with unchecked numbers and then swap them around (but not swapping hint cells) until no rules are being broken. Is potentially a bit of a bogosort situation but might be fun to implement.

For more information on each algorithm, check out SudokuSolver/docs/algorithms

### How to use:
My _SudokuBoardReader_ class can handle a few different file formats, but what has been easiest for me is to use comma-separated values for each cell in the board, going to a new line for each row. I have some prebuilt 9x9 and 16x16 input boards that can be used of varying difficulties. While I don't have the multi-threading set up yet to show the process, you can see how the different algorithms solve different boards in SudokuUI by changing the boardFile variable to the file of the board you wish to solve, and change which (if any) algorithms to run in the try block of the SudokuUI constructor. After you've got it set up to run as you'd like, you can just run the SudokuUI.java file.
